/*
    Copyright (C) 2021-2025 George Cave - gcave@stablecoder.ca

    SPDX-License-Identifier: Apache-2.0

    This file was auto-generated by the Vulkan Mini Libs 2 utility:
    https://github.com/stablecoder/vulkan-mini-libs-2.git
    or
    https://git.stabletec.com/utilities/vulkan-mini-libs-2.git

    Check for an updated version anytime, or state concerns/bugs.
*/

#ifndef VK_RESULT_TO_STRING_H
#define VK_RESULT_TO_STRING_H

/*  USAGE
    To use, include this header where the declarations for the boolean checks are required.

    On *ONE* compilation unit, include the definition of:
    #define VK_RESULT_TO_STRING_CONFIG_MAIN

    so that the definitions are compiled somewhere following the one definition rule.
*/

#ifdef __cplusplus
extern "C" {
#endif

#include <vulkan/vulkan.h>

#ifdef __cplusplus
static_assert(VK_HEADER_VERSION >= 72,
              "VK_HEADER_VERSION is lower than the minimum supported version (v72)");
#else
_Static_assert(VK_HEADER_VERSION >= 72,
               "VK_HEADER_VERSION is lower than the minimum supported version (v72)");
#endif

#if VK_HEADER_VERSION > 326
#if _MSC_VER
#pragma message(                                                                                   \
    __FILE__ ": warning: VK_HEADER_VERSION is higher than what the header fully supports (v326)")
#else
#warning "VK_HEADER_VERSION is higher than what the header fully supports (v326)"
#endif
#endif

/// Returns a string representing the given VkResult parameter. If there is no known representation,
/// returns NULL.
char const *VkResult_to_string(VkResult result);

/// Similar to VkResult_to_string, except in the case where it is an unknown value, returns a string
/// stating '(unrecognized positive/negative VkResult value)', thus never returning NULL.
char const *vkResultToString(VkResult result);

#ifdef VK_RESULT_TO_STRING_CONFIG_MAIN

char const *VkResult_to_string(VkResult result) {
  // Check in descending order to get the 'latest' version of the error code text available.
  // Also, because codes have been re-used over time, can't use a switch and have to do this large
  // set of ifs. Luckily this *should* be a relatively rare call.

  switch (result) {
  case 0:
    return "VK_SUCCESS";
  case 1:
    return "VK_NOT_READY";
  case 2:
    return "VK_TIMEOUT";
  case 3:
    return "VK_EVENT_SET";
  case 4:
    return "VK_EVENT_RESET";
  case 5:
    return "VK_INCOMPLETE";
  case -1:
    return "VK_ERROR_OUT_OF_HOST_MEMORY";
  case -2:
    return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
  case -3:
    return "VK_ERROR_INITIALIZATION_FAILED";
  case -4:
    return "VK_ERROR_DEVICE_LOST";
  case -5:
    return "VK_ERROR_MEMORY_MAP_FAILED";
  case -6:
    return "VK_ERROR_LAYER_NOT_PRESENT";
  case -7:
    return "VK_ERROR_EXTENSION_NOT_PRESENT";
  case -8:
    return "VK_ERROR_FEATURE_NOT_PRESENT";
  case -9:
    return "VK_ERROR_INCOMPATIBLE_DRIVER";
  case -10:
    return "VK_ERROR_TOO_MANY_OBJECTS";
  case -11:
    return "VK_ERROR_FORMAT_NOT_SUPPORTED";
  case -12:
    return "VK_ERROR_FRAGMENTED_POOL";
  case -13:
    return "VK_ERROR_UNKNOWN";
  case -1000069000:
    return "VK_ERROR_OUT_OF_POOL_MEMORY";
  case -1000072003:
    return "VK_ERROR_INVALID_EXTERNAL_HANDLE";
  case -1000161000:
    return "VK_ERROR_FRAGMENTATION";
  case -1000257000:
    return "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS";
  case 1000297000:
    return "VK_PIPELINE_COMPILE_REQUIRED";
  case -1000174001:
    return "VK_ERROR_NOT_PERMITTED";
  case -1000000000:
    return "VK_ERROR_SURFACE_LOST_KHR";
  case -1000000001:
    return "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR";
  case 1000001003:
    return "VK_SUBOPTIMAL_KHR";
  case -1000001004:
    return "VK_ERROR_OUT_OF_DATE_KHR";
  case -1000003001:
    return "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR";
  case -1000012000:
    return "VK_ERROR_INVALID_SHADER_NV";
  case -1000023000:
    return "VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR";
  case -1000023001:
    return "VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR";
  case -1000023002:
    return "VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR";
  case -1000023003:
    return "VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR";
  case -1000023004:
    return "VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR";
  case -1000023005:
    return "VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR";
  case -1000158000:
    return "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT";
  case -1000255000:
    return "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT";
  case 1000268000:
    return "VK_THREAD_IDLE_KHR";
  case 1000268001:
    return "VK_THREAD_DONE_KHR";
  case 1000268002:
    return "VK_OPERATION_DEFERRED_KHR";
  case 1000268003:
    return "VK_OPERATION_NOT_DEFERRED_KHR";
  case -1000299000:
    return "VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR";
  case -1000338000:
    return "VK_ERROR_COMPRESSION_EXHAUSTED_EXT";
  case 1000482000:
    return "VK_INCOMPATIBLE_SHADER_BINARY_EXT";
  case 1000483000:
    return "VK_PIPELINE_BINARY_MISSING_KHR";
  case -1000483000:
    return "VK_ERROR_NOT_ENOUGH_SPACE_KHR";
  case -1000150000:
    return "VK_ERROR_INCOMPATIBLE_VERSION_KHR";

  default:
    return NULL;
  }
}

char const *vkResultToString(VkResult result) {
  char const *pResultString = VkResult_to_string(result);
  if (pResultString != NULL)
    return pResultString;

  if (result > 0)
    return "(unrecognized positive VkResult value)";
  else
    return "(unrecognized negative VkResult value)";
}

#endif // VK_RESULT_TO_STRING_CONFIG_MAIN

#ifdef __cplusplus
}
#endif

#endif // VK_RESULT_TO_STRING_H
